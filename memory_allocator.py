# -*- coding: utf-8 -*-
"""advos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ecnUl_Cm2eBHkOmFIUbT85o14IxuPXL
"""

class MemoryAllocator:
    def __init__(self, size):
        self.MAX = size
        self.memory = [("Unused", 0, size - 1)]

    def request_memory(self, process_id, size):
        if size <= 0:
            return f"Error: Invalid size. Size must be positive."

        unused_blocks = []
        for i, block in enumerate(self.memory):
            if block[0] == "Unused":
                block_size = block[2] - block[1] + 1
                if block_size >= size:
                    unused_blocks.append((i, block_size))

        if not unused_blocks:
            return f"Error: Not enough contiguous memory for process {process_id} ({size} KB)."

        # Always use First-Fit strategy
        selected_index = unused_blocks[0][0]

        start_address = self.memory[selected_index][1]
        end_address = self.memory[selected_index][2]
        block_size = end_address - start_address + 1

        if block_size == size:
            self.memory[selected_index] = (f"Process {process_id}", start_address, end_address)
        else:
            self.memory[selected_index] = (f"Process {process_id}", start_address, start_address + size - 1)
            self.memory.insert(selected_index + 1, ("Unused", start_address + size, end_address))

        return f"Allocated {size} KB to Process {process_id} at addresses [{start_address}:{start_address + size - 1}]"

    def release_memory(self, process_id):
        process_blocks = []
        for i, block in enumerate(self.memory):
            if block[0] == f"Process {process_id}":
                process_blocks.append(i)

        if not process_blocks:
            return f"Error: No memory allocated to Process {process_id}."

        for i in sorted(process_blocks, reverse=True):
            start_address = self.memory[i][1]
            end_address = self.memory[i][2]
            self.memory[i] = ("Unused", start_address, end_address)

        self.merge_adjacent_holes()
        return f"Released memory allocated to Process {process_id}"

    def merge_adjacent_holes(self):
        i = 0
        while i < len(self.memory) - 1:
            current = self.memory[i]
            next_block = self.memory[i + 1]
            if current[0] == "Unused" and next_block[0] == "Unused":
                merged = ("Unused", current[1], next_block[2])
                self.memory[i] = merged
                del self.memory[i + 1]
            else:
                i += 1

    def compact_memory(self):
        allocated_blocks = [b for b in self.memory if b[0] != "Unused"]
        total_allocated = sum(b[2] - b[1] + 1 for b in allocated_blocks)

        new_memory = []
        current_address = 0

        for status, _, end in allocated_blocks:
            block_size = end - _ + 1
            new_memory.append((status, current_address, current_address + block_size - 1))
            current_address += block_size

        if current_address < self.MAX:
            new_memory.append(("Unused", current_address, self.MAX - 1))

        self.memory = new_memory
        return "Memory compaction completed successfully."

    def status_report(self):
        report = ["Current Memory Layout:"]
        for status, start, end in self.memory:
            size = end - start + 1
            report.append(f"{size} KB - {status}")
        return "\n".join(report)


def interactive_allocator():
    # Set default memory size to 500 KB
    memory_size = 500
    print(f"Memory size set to {memory_size} KB")
    allocator = MemoryAllocator(memory_size)

    # Ask for number of initial processes
    num_processes = int(input("Enter the number of processes you want to add: "))

    # Add processes
    for i in range(1, num_processes + 1):
        process_size = int(input(f"Enter size of Process P{i} (in KB): "))
        print(allocator.request_memory(f"P{i}", process_size))

    print("\n" + allocator.status_report())

    # Loop for user interaction
    while True:
        print("\n--- Main Menu ---")
        print("1. Add new process")
        print("2. Release a process")
        print("3. Show memory status")
        print("4. Perform memory compaction")
        print("5. Exit")

        choice = input("Your choice: ")

        if choice == "1":
            process_id = input("Enter process ID (e.g., P4): ")
            process_size = int(input(f"Enter size of process {process_id} (in KB): "))

            result = allocator.request_memory(process_id, process_size)
            print(result)

            if "Error" in result and "Not enough contiguous memory" in result:
                print("\nExternal Fragmentation problem detected!")
                do_compact = input("Do you want to perform memory compaction? (yes/no): ").lower()

                if do_compact == "yes":
                    print(allocator.compact_memory())
                    print(allocator.status_report())
                    print("\nTrying to allocate memory again after compaction...")
                    print(allocator.request_memory(process_id, process_size))

        elif choice == "2":
            process_id = input("Enter the process ID you want to release: ")
            print(allocator.release_memory(process_id))
            print(allocator.status_report())

        elif choice == "3":
            print(allocator.status_report())

        elif choice == "4":
            print(allocator.compact_memory())
            print(allocator.status_report())

        elif choice == "5":
            print("Thank you for using Memory Allocator!")
            break

        else:
            print("Invalid choice. Please try again.")


if __name__ == "__main__":
    interactive_allocator()